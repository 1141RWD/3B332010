<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Antigravity Tactics v1.4</title>
    <link rel="stylesheet" href="styles.css?v=1.4">
    <link rel="stylesheet" href="setup_modal.css?v=1.4">
</head>

<body>
    <!-- Game Setup Modal -->
    <div id="setupModal" class="modal-overlay">
        <div class="setup-modal">
            <h2>éŠæˆ²é–‹å§‹ - å¸ƒé™£é¸æ“‡ v1.4</h2>

            <!-- Step 1: Red -->
            <div id="setupStepRed" class="setup-step active">
                <div class="player-title-red">ç´…æ–¹é¸æ“‡å¸ƒé™£</div>
                <div class="formation-list" id="redList">
                    <!-- Populated by JS -->
                </div>
                <button id="btnConfirmRed" class="btn-confirm" disabled onclick="confirmRed()">ä¸‹ä¸€æ­¥</button>
            </div>

            <!-- Step 2: Blue -->
            <div id="setupStepBlue" class="setup-step">
                <div class="player-title-blue">è—æ–¹é¸æ“‡å¸ƒé™£</div>
                <div class="formation-list" id="blueList">
                    <!-- Populated by JS -->
                </div>
                <button id="btnConfirmBlue" class="btn-confirm" disabled onclick="confirmBlue()">é–‹å§‹éŠæˆ²</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- å·¦å´é¢æ¿ï¼šå›åˆæŒ‡ç¤º -->
        <div class="side-panel left-panel">
            <div id="turnIndicator" class="turn-indicator turn-red">ç´…æ–¹å›åˆ</div>
            <div id="victoryMessage" class="victory-message" style="display: none;"></div>
        </div>

        <!-- ä¸­é–“é¢æ¿ï¼šæ£‹ç›¤ -->
        <div class="board-container">
            <div id="gameBoard" class="game-board"></div>
            <!-- Aura Overlay for General's Protection -->
            <svg id="auraOverlay" width="100%" height="100%"
                style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5;">
                <defs>
                    <filter id="trembleFilter" x="-20%" y="-20%" width="140%" height="140%">
                        <!-- Increased scale and adapted frequency for visible "electric" arcs -->
                        <feTurbulence id="turbulenceNoise" type="turbulence" baseFrequency="0.03" numOctaves="1"
                            result="noise" seed="0">
                            <!-- Removed SMIL animate, now handled by JS -->
                        </feTurbulence>
                        <feDisplacementMap in="SourceGraphic" in2="noise" scale="15" xChannelSelector="R"
                            yChannelSelector="G" />
                    </filter>
                </defs>
            </svg>
            <svg id="attackRangeOverlay" width="100%" height="100%" style="z-index: 10;"></svg>
            <!-- ä¸­å¤®æç¤ºè¨Šæ¯ -->
            <div id="centralMessage" class="central-message"></div>
        </div>

        <!-- å³å´é¢æ¿ï¼šç´€éŒ„èˆ‡æ§åˆ¶ -->
        <div class="side-panel right-panel">
            <div class="log-panel">
                <h3>æˆ°é¬¥ç´€éŒ„</h3>
                <div id="logContent" class="log-content"></div>
            </div>

            <div class="controls-area">
                <div id="apCounter" class="ap-counter-bottom">AP: 6</div>
                <div class="controls">
                    <button class="btn-end-turn" onclick="endTurn()">çµæŸå›åˆ</button>
                    <button class="btn-reset" onclick="resetGame()">é‡æ–°é–‹å§‹</button>
                    <button class="btn-toggle-log" onclick="toggleLog()">ğŸ“‹ æˆ°é¬¥è¨˜éŒ„</button>
                </div>
            </div>
        </div>
    </div>

    <!-- æˆ°é¬¥è¨˜éŒ„å½ˆå‡ºè¦–çª—ï¼ˆæ‰‹æ©Ÿç‰ˆä½¿ç”¨ï¼‰ -->
    <div id="logModal" class="log-modal">
        <div class="log-modal-content">
            <div class="log-modal-header">
                <h3>æˆ°é¬¥è¨˜éŒ„</h3>
                <button class="log-modal-close" onclick="toggleLog()">âœ•</button>
            </div>
            <div id="logModalContent" class="log-modal-body"></div>
        </div>
    </div>

    <script src="game-logic.js"></script>
    <script src="ai.js"></script>
    <script>
        let gameEngine = null;
        let aiController = null;
        let currentSetupData = null; // Store for restart
        let isPVE = false;

        // PVE Initialization Check
        function checkAndInitPVE() {
            const params = new URLSearchParams(window.location.search);
            if (params.get('mode') === 'pve') {
                isPVE = true;
                const configRaw = sessionStorage.getItem('antigravity_pve_config');
                if (!configRaw) {
                    alert('æ‰¾ä¸åˆ° PVE è¨­å®šï¼Œå°‡è¿”å›ä¸»é¸å–®');
                    window.location.href = 'index.html';
                    return;
                }
                const config = JSON.parse(configRaw);
                initPVEGame(config);
            } else {
                // Determine normal flow (init modal)
                try {
                    initSetupModal();
                } catch (e) {
                    console.error('Error in initSetupModal:', e);
                    alert('åˆå§‹åŒ–é¸å–®å¤±æ•—ï¼š' + e.message);
                }
            }
        }

        function initPVEGame(config) {
            const formations = JSON.parse(localStorage.getItem('antigravity_formations') || '{}');
            const customSetup = { red: null, blue: null };

            // Blue: Player selected setup
            if (config.playerFormation && config.playerFormation !== 'default') {
                const raw = formations[config.playerFormation];
                // WYSIWYG for Blue (v1.4)
                customSetup.blue = raw.map(u => ({
                    type: u.type,
                    x: u.x,
                    y: 11 + u.y
                }));
            }
            // Red: Default

            currentSetupData = customSetup;
            gameState = gameEngine.initGameState(customSetup);

            // Override Turn Order
            if (config.firstTurn === 'blue') {
                gameState.current_turn = 'blue';
            } else {
                gameState.current_turn = 'red';
            }

            // Init AI
            aiController = new AIController(gameEngine, 'red', config.difficulty);

            // Hide Setup UI
            const modal = document.getElementById('setupModal');
            if (modal) modal.style.display = 'none';
            document.getElementById('victoryMessage').style.display = 'none';
            document.getElementById('centralMessage').style.display = 'none';

            renderBoard();
            updateUI();

            const diffText = config.difficulty === 'easy' ? 'ç°¡å–®' : 'å›°é›£';
            addLog(`å–®äººæ¨¡å¼é–‹å§‹ï¼é›£åº¦ï¼š${diffText}`);

            if (gameState.current_turn === 'red') {
                addLog('é›»è…¦ (ç´…æ–¹) å›åˆé–‹å§‹');
                processAITurn();
            } else {
                addLog('ç©å®¶ (è—æ–¹) å›åˆé–‹å§‹');
                showCentralMessage('ä½ çš„å›åˆ', 'turn');
            }
        }

        async function processAITurn() {
            if (!isPVE || gameState.current_turn !== 'red' || gameState.game_over) return;

            document.body.style.cursor = 'wait';

            // AI Loop (Action by Action)
            let turnActive = true;
            while (turnActive && gameState.current_turn === 'red' && !gameState.game_over) {
                const result = await aiController.decideAndExecute();

                if (result.success) {
                    // Animation if Attack
                    if (result.ai_context && result.ai_context.action_type === 'attack') {
                        const attacker = {
                            id: result.ai_context.unit_id,
                            type: result.ai_context.unit_type,
                            team: 'red'
                        };
                        // Use old DOM state for animation start/end points
                        await animateAttack(attacker, result.ai_context.target.x, result.ai_context.target.y);
                    }

                    gameState = gameEngine.state;
                    renderBoard();
                    updateUI();

                    // Log AI Action
                    if (result.ai_context) {
                        const uName = UNIT_NAMES[result.ai_context.unit_type] || result.ai_context.unit_type;
                        let actType = 'æœªçŸ¥è¡Œå‹•';
                        if (result.ai_context.action_type === 'move') actType = 'ç§»å‹•åˆ°';
                        else if (result.ai_context.action_type === 'attack') actType = 'æ”»æ“Š';
                        else if (result.ai_context.action_type === 'skill') actType = 'ç™¼å‹•æŠ€èƒ½';

                        const tgt = `(${result.ai_context.target.x}, ${result.ai_context.target.y})`;
                        // Use a specific style for enemy actions so they stand out
                        addLog(`é›»è…¦ ${uName} ${actType} ${tgt}`, 'enemy-action');
                    } else if (result.ai_give_up) {
                        addLog('é›»è…¦ç„¡è¨ˆå¯æ–½ï¼Œåœæ­¢è¡Œå‹•');
                        turnActive = false;
                    } else if (result.message === 'å›åˆçµæŸ') {
                        addLog('é›»è…¦çµæŸå›åˆ');
                    }

                    if (result.message === 'å›åˆçµæŸ' || result.auto_turn_end) {
                        turnActive = false;
                    }
                } else {
                    console.error("AI Error:", result.error);
                    turnActive = false;
                    await endTurn(true);
                }

                if (result.auto_turn_end && gameState.current_turn === 'red') {
                    turnActive = false;
                    await endTurn(true);
                }
            }
            document.body.style.cursor = 'default';

            // If AI loop finished but it's still Red's turn (e.g. AI gave up), 
            // re-enable "End Turn" button so user can force it.
            if (isPVE && gameState.current_turn === 'red') {
                const endTurnBtn = document.querySelector('.btn-end-turn');
                if (endTurnBtn) endTurnBtn.style.display = 'inline-block';
            }
        }

        // ... existing initGame ...

        // åˆå§‹åŒ–éŠæˆ² (Updated)
        function initGame(setupData = null) {
            // If setupData is provided (new game), save it. 
            // If null (called from elsewhere without args), try to use saved.
            // But be careful: resetGame calls initGame(). 
            // Better: resetGame calls initGame(currentSetupData).

            if (setupData) {
                currentSetupData = setupData;
            } else if (currentSetupData) {
                // If initGame() called without args but we have history (shouldn't happen often if we fix resetGame)
                setupData = currentSetupData;
            }

            gameState = gameEngine.initGameState(setupData);
            // ... rest of init ...

            // éš±è—æ‰€æœ‰æç¤ºè¨Šæ¯
            document.getElementById('victoryMessage').style.display = 'none';
            document.getElementById('centralMessage').style.display = 'none';

            renderBoard();
            updateUI();
            addLog('éŠæˆ²é–‹å§‹ï¼ç´…æ–¹å…ˆæ‰‹');
        }

        // ...

        function resetGame() {
            if (isPVE) {
                // å–®äººæ¨¡å¼ï¼šè¿”å›å–®äººæ¨¡å¼è¨­å®šé é¢
                if (confirm('ç¢ºå®šè¦é‡æ–°é–‹å§‹å—ï¼Ÿ\n(å°‡è¿”å›é™£å‹é¸æ“‡é é¢)')) {
                    // æ¸…é™¤ session storage
                    sessionStorage.removeItem('antigravity_pve_config');
                    // å°èˆªå›å–®äººæ¨¡å¼è¨­å®šé é¢
                    window.location.href = 'single_player.html';
                }
            } else {
                // é›™äººæ¨¡å¼ï¼šé‡æ–°è¼‰å…¥é é¢ä¸¦é‡æ–°é¸æ“‡é™£å‹
                if (confirm('ç¢ºå®šè¦é‡æ–°é–‹å§‹å—ï¼Ÿ\n(å°‡æœƒé‡æ–°è¼‰å…¥é é¢ä¸¦é‡æ–°é¸æ“‡é™£å‹)')) {
                    location.reload();
                }
            }
        }
        let actionMode = null; // null, 'select_action', 'move', 'attack'
        let actionMenu = null;
        let mouseMoveHandler = null;
        let boardRect = null;

        let selectedFormationRed = null;
        let selectedFormationBlue = null;

        // Init Sequence
        window.onload = function () {
            console.log('Window loaded. Initializing...');

            // 1. Check if GameEngine class is loaded
            if (typeof GameEngine === 'undefined') {
                console.error('GameEngine class is undefined!');
                alert('åš´é‡éŒ¯èª¤ï¼šç„¡æ³•è¼‰å…¥éŠæˆ²å¼•æ“ (game-logic.js)ã€‚\nè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦å­˜åœ¨æˆ–èªæ³•éŒ¯èª¤ã€‚\n(è«‹æŒ‰ F12 æŸ¥çœ‹ Console)');
                return;
            }

            // 2. Initialize GameEngine safely
            try {
                gameEngine = new GameEngine();
                console.log('GameEngine initialized successfully.');

                // 3. Init PVE or Normal
                checkAndInitPVE();

            } catch (e) {
                console.error('Error instantiating GameEngine:', e);
                alert('åš´é‡éŒ¯èª¤ï¼šéŠæˆ²å¼•æ“åˆå§‹åŒ–å¤±æ•—ã€‚\n' + e.message);
                return;
            }
        };

        function initSetupModal() {
            let formations = {};
            try {
                const raw = localStorage.getItem('antigravity_formations');
                if (raw) {
                    formations = JSON.parse(raw);
                }
            } catch (e) {
                console.error('Failed to parse formations:', e);
                // Reset or ignore corrupt data
                formations = {};
            }

            // Populate Red List
            const redList = document.getElementById('redList');
            if (redList) {
                console.log('Populating Red List...');
                populateFormationList(redList, formations, 'red');
            } else {
                console.error('Element #redList not found');
            }

            // Populate Blue List
            const blueList = document.getElementById('blueList');
            if (blueList) {
                console.log('Populating Blue List...');
                populateFormationList(blueList, formations, 'blue');
            } else {
                console.error('Element #blueList not found');
            }
        }

        function populateFormationList(container, formations, team) {
            container.innerHTML = '';
            console.log(`Populating list for ${team}, formations found:`, Object.keys(formations).length);

            // Default Option
            const defDiv = document.createElement('div');
            defDiv.className = 'formation-option';
            defDiv.innerHTML = `<span>é è¨­é™£å‹ (å®˜æ–¹è¨­å®š)</span>`;
            defDiv.onclick = () => selectFormation(team, 'default', defDiv);
            container.appendChild(defDiv);

            // Custom Options
            Object.keys(formations).forEach(name => {
                const div = document.createElement('div');
                div.className = 'formation-option';
                div.innerHTML = `<span>${name}</span>`;
                div.onclick = () => selectFormation(team, name, div);
                container.appendChild(div);
            });
        }

        function selectFormation(team, name, el) {
            // Updated UI
            const container = team === 'red' ? document.getElementById('redList') : document.getElementById('blueList');
            container.querySelectorAll('.formation-option').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');

            // Enable Button
            const btn = team === 'red' ? document.getElementById('btnConfirmRed') : document.getElementById('btnConfirmBlue');
            btn.disabled = false;

            // Save Choice
            if (team === 'red') selectedFormationRed = name;
            else selectedFormationBlue = name;
        }

        function confirmRed() {
            document.getElementById('setupStepRed').classList.remove('active');
            document.getElementById('setupStepBlue').classList.add('active');
        }

        function confirmBlue() {
            document.getElementById('setupModal').style.display = 'none';
            initGameWithSetup();
        }

        function initGameWithSetup() {
            const formations = JSON.parse(localStorage.getItem('antigravity_formations') || '{}');

            const customSetup = { red: null, blue: null };

            // Load Red
            if (selectedFormationRed && selectedFormationRed !== 'default') {
                // UPDATE: User requested Mirroring for Red Custom Formation.
                // Mirror Left<->Right (X) and Top<->Bottom (Y within zone).
                // Red Zone Height = 4 (Y=0 to 3). Max X = 12.
                const raw = formations[selectedFormationRed];
                customSetup.red = raw.map(u => ({
                    type: u.type,
                    x: 12 - u.x,
                    y: 3 - u.y
                }));
            }

            // Load Blue
            if (selectedFormationBlue && selectedFormationBlue !== 'default') {
                // UPDATE: User feedback "Direction is wrong".
                // Previous Logic: Mirror Y (14-y) and Mirror X (12-x).
                // Issue: If user builds formation expecting "Top-Left of Editor" -> "Top-Left of Deployment Zone",
                // then Mirror logic reverses it.
                //
                // New Logic: Direct Translation.
                // Blue Zone starts at Y=11.
                // Editor Y=0 -> Game Y=11. (Front line? No, Y=11 is top of zone / front line for Blue).
                // Editor X=0 -> Game X=0. (Left is Left).

                const raw = formations[selectedFormationBlue];
                customSetup.blue = raw.map(u => ({
                    type: u.type,
                    x: u.x,         // Keep X same (Left is Left)
                    y: 11 + u.y     // Shift Y to start at 11
                }));
            }

            initGame(customSetup);
        }

        // åˆå§‹åŒ–éŠæˆ² (Updated)
        function initGame(setupData = null) {
            gameState = gameEngine.initGameState(setupData);
            // éš±è—æ‰€æœ‰æç¤ºè¨Šæ¯
            document.getElementById('victoryMessage').style.display = 'none';
            document.getElementById('centralMessage').style.display = 'none';
            // Start BGM if available
            // const bgm = document.getElementById('bgm');
            // if(bgm) bgm.play();

            renderBoard();
            updateUI();
            addLog('éŠæˆ²é–‹å§‹ï¼ç´…æ–¹å…ˆæ‰‹');
        }

        // æ¸²æŸ“æ£‹ç›¤
        function renderBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';

            for (let y = 0; y < 15; y++) {
                for (let x = 0; x < 13; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    const unit = gameState.board[`${x}_${y}`];

                    if (unit) {
                        if (unit.type === 'obstacle') {
                            cell.classList.add('obstacle');
                            const obstacleImg = document.createElement('img');
                            obstacleImg.className = 'unit-img';
                            obstacleImg.src = 'assets/obstacle.png';
                            obstacleImg.alt = 'éšœç¤™ç‰©';
                            cell.appendChild(obstacleImg);
                        } else {
                            cell.classList.add(unit.team + '-unit');

                            // ä½¿ç”¨åœ–ç‰‡å–ä»£æ–‡å­—å­—å…ƒ
                            const unitImg = document.createElement('img');
                            unitImg.className = 'unit-img';
                            unitImg.src = `assets/${unit.type}.png`;
                            unitImg.alt = UNIT_NAMES[unit.type];
                            // åœ–ç‰‡è¼‰å…¥å¤±æ•—æ™‚å›é€€åˆ°æ–‡å­—
                            unitImg.onerror = function () {
                                this.style.display = 'none';
                                const fallbackText = document.createElement('div');
                                fallbackText.className = 'unit-type';
                                fallbackText.textContent = UNIT_NAMES[unit.type];
                                cell.insertBefore(fallbackText, cell.firstChild);
                            };

                            const unitHP = document.createElement('div');
                            unitHP.className = 'unit-hp';
                            unitHP.textContent = `${unit.hp}/${unit.max_hp}`;

                            const hpBar = document.createElement('div');
                            hpBar.className = 'hp-bar';
                            const hpFill = document.createElement('div');
                            hpFill.className = 'hp-fill';
                            hpFill.style.width = `${(unit.hp / unit.max_hp) * 100}%`;
                            hpBar.appendChild(hpFill);

                            cell.appendChild(unitImg);
                            cell.appendChild(unitHP);
                            cell.appendChild(hpBar);

                            // é¡¯ç¤ºç‚®çš„å†·å»ç‹€æ…‹
                            if (unit.type === 'can' && unit.cooldown > 0) {
                                const cooldownIndicator = document.createElement('div');
                                cooldownIndicator.className = 'cooldown-indicator';
                                cooldownIndicator.textContent = `å†·å»:${unit.cooldown}`;
                                cell.appendChild(cooldownIndicator);
                            }
                        }
                    }

                    cell.onclick = () => handleCellClick(x, y);
                    board.appendChild(cell);
                }
            }

            // ç¹ªè£½å°‡è»çš„å…‰ç’°ç‰¹æ•ˆ
            setTimeout(drawAuraEffects, 0); // Ensure DOM is rendered
        }

        // Loop removed - Switching to CSS animation

        // ç¹ªè£½å°‡è»çš„å…‰ç’°ç‰¹æ•ˆ
        function drawAuraEffects() {
            const svg = document.getElementById('auraOverlay');
            if (!svg) return;

            // Remove existing aura borders
            const existing = svg.querySelectorAll('.aura-border');
            existing.forEach(el => el.remove());

            const container = document.querySelector('.board-container');
            const containerRect = container.getBoundingClientRect();

            // Iterate board to find Generals
            for (const [key, unit] of Object.entries(gameState.board)) {
                if (unit.type === 'gen' && unit.aura_active) {
                    const [gx, gy] = key.split('_').map(Number);

                    // Determine covered cells (clamped to board)
                    const minX = Math.max(0, gx - 2);
                    const maxX = Math.min(12, gx + 2);
                    const minY = Math.max(0, gy - 2);
                    const maxY = Math.min(14, gy + 2);

                    // Get bounding box of these cells
                    const tlCell = document.querySelector(`.cell[data-x="${minX}"][data-y="${minY}"]`);
                    const brCell = document.querySelector(`.cell[data-x="${maxX}"][data-y="${maxY}"]`);

                    if (tlCell && brCell) {
                        const tlRect = tlCell.getBoundingClientRect();
                        const brRect = brCell.getBoundingClientRect();

                        // Relative to container
                        const x1 = tlRect.left - containerRect.left;
                        const y1 = tlRect.top - containerRect.top;
                        const x2 = brRect.right - containerRect.left;
                        const y2 = brRect.bottom - containerRect.top;

                        const width = x2 - x1;
                        const height = y2 - y1;

                        // Draw Rect (using path for potentially more complex shapes if needed, but rect is fine)
                        // Using rect for simplicity
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        rect.setAttribute("x", x1);
                        rect.setAttribute("y", y1);
                        rect.setAttribute("width", width);
                        rect.setAttribute("height", height);
                        rect.setAttribute("rx", "15"); // rounded corners to look smoother
                        rect.setAttribute("ry", "15");
                        rect.setAttribute("class", `aura-border aura-border-${unit.team}`);

                        svg.appendChild(rect);
                    }
                }
            }
        }

        // è™•ç†æ ¼å­é»æ“Š
        async function handleCellClick(x, y) {
            if (gameState.game_over) {
                alert('éŠæˆ²å·²çµæŸï¼');
                return;
            }

            // PVE AI Turn Blocking
            if (isPVE && gameState.current_turn === 'red') {
                return;
            }

            const unit = gameState.board[`${x}_${y}`];

            // ç§»å‹•æ¨¡å¼ï¼šé»æ“Šç¶ è‰²æ ¼å­ç§»å‹•ï¼Œå…¶ä»–å–æ¶ˆ
            if (actionMode === 'move') {
                const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                if (cell.classList.contains('move-highlight')) {
                    await performMove(x, y);
                } else {
                    cancelAction();
                    addLog('å–æ¶ˆç§»å‹•');
                }
                return;
            }

            // æ”»æ“Šæ¨¡å¼ï¼šé»æ“Šç›®æ¨™æ”»æ“Šï¼Œå…¶ä»–å–æ¶ˆ
            if (actionMode === 'attack') {
                const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                if (cell.classList.contains('attack-target')) {
                    await performAttack(x, y);
                } else {
                    cancelAction();
                    addLog('å–æ¶ˆæ”»æ“Š');
                }
                return;
            }

            // é»æ“Šå·±æ–¹å–®ä½ -> é¡¯ç¤ºæ“ä½œé¸å–®
            if (unit && unit.team === gameState.current_turn && unit.type !== 'obstacle') {
                selectedUnit = unit;
                selectedPos = { x, y };
                showActionMenu(x, y);
                addLog(`é¸æ“‡äº† ${unit.team === 'red' ? 'ç´…æ–¹' : 'è—æ–¹'} ${UNIT_NAMES[unit.type]} (${x},${y})`);
                return;
            }

            // é»æ“Šå…¶ä»–åœ°æ–¹å–æ¶ˆé¸æ“‡
            if (selectedUnit || actionMode) {
                cancelAction();
            }
        }

        // é¡¯ç¤ºæ“ä½œé¸å–®
        function showActionMenu(x, y) {
            // åªæ¸…é™¤æ“ä½œç‹€æ…‹ï¼Œä¸æ¸…é™¤é¸ä¸­çš„å–®ä½ä¿¡æ¯
            if (actionMenu) {
                actionMenu.remove();
                actionMenu = null;
            }
            if (mouseMoveHandler) {
                document.removeEventListener('mousemove', mouseMoveHandler);
                mouseMoveHandler = null;
            }
            const svg = document.getElementById('attackRangeOverlay');
            if (svg) svg.innerHTML = '';
            document.querySelectorAll('.move-highlight, .attack-target, .splash-target').forEach(el => {
                el.classList.remove('move-highlight', 'attack-target', 'splash-target');
            });

            actionMode = 'select_action';
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (cell) cell.classList.add('selected');

            // å‰µå»ºé¸å–®
            actionMenu = document.createElement('div');
            actionMenu.className = 'action-menu';

            // é¡¯ç¤ºå–®ä½åç¨±
            const title = document.createElement('div');
            title.className = 'action-menu-title';
            title.textContent = UNIT_NAMES[selectedUnit.type];
            actionMenu.appendChild(title);

            const btnContainer = document.createElement('div');
            btnContainer.style.display = 'flex';
            btnContainer.style.gap = '10px';
            btnContainer.style.justifyContent = 'center';

            const moveBtn = document.createElement('button');
            moveBtn.className = 'action-btn action-btn-move';
            moveBtn.textContent = 'ç§»å‹•';
            moveBtn.onclick = (e) => {
                e.stopPropagation();
                enterMoveMode();
            };

            const attackBtn = document.createElement('button');
            attackBtn.className = 'action-btn action-btn-attack';
            attackBtn.textContent = 'æ”»æ“Š';
            attackBtn.onclick = (e) => {
                e.stopPropagation();
                // æª¢æŸ¥ç‚®æ˜¯å¦è™•æ–¼å†·å»ä¸­
                if (selectedUnit.type === 'can' && selectedUnit.cooldown > 0) {
                    alert(`ç‚®è™•æ–¼å†·å»ä¸­ (å‰©é¤˜ ${selectedUnit.cooldown} å›åˆ)`);
                    return;
                }
                enterAttackMode();
            };

            btnContainer.appendChild(moveBtn);
            btnContainer.appendChild(attackBtn);

            // å°‡è»ç‰¹æ®ŠæŠ€èƒ½ï¼šæ¸›å‚·é ˜åŸŸ
            if (selectedUnit.type === 'gen') {
                const auraBtn = document.createElement('button');
                auraBtn.className = 'action-btn';
                auraBtn.textContent = 'æ¸›å‚·é ˜åŸŸ';
                auraBtn.style.backgroundColor = '#ffd700'; // Gold color
                auraBtn.style.color = '#000';

                if (selectedUnit.aura_active) {
                    auraBtn.disabled = true;
                    auraBtn.textContent = `å·²é–‹å•Ÿ(${selectedUnit.aura_turns})`;
                    auraBtn.style.opacity = '0.6';
                    auraBtn.style.cursor = 'not-allowed';
                } else if (selectedUnit.aura_cooldown > 0) {
                    auraBtn.disabled = true;
                    auraBtn.textContent = `å†·å»ä¸­(${selectedUnit.aura_cooldown})`;
                    auraBtn.style.opacity = '0.6';
                    auraBtn.style.cursor = 'not-allowed';
                }

                auraBtn.onclick = (e) => {
                    e.stopPropagation();
                    const result = gameEngine.activateAura(selectedUnit.id);
                    if (result.success) {
                        gameState = gameEngine.state;
                        addLog(`${selectedUnit.team === 'red' ? 'ç´…æ–¹' : 'è—æ–¹'}å°‡è» ${result.message}`);
                        cancelAction();
                        updateUI();
                        // æª¢æŸ¥æ˜¯å¦éœ€è¦è‡ªå‹•æ›å›åˆ
                        if (result.auto_turn_end) {
                            setTimeout(() => {
                                endTurn(true);
                            }, 500);
                        }
                    } else {
                        alert(result.error);
                    }
                };
                btnContainer.appendChild(auraBtn);
            }
            actionMenu.appendChild(btnContainer);

            // å®šä½é¸å–®
            const boardContainer = document.querySelector('.board-container');
            const cellRect = cell.getBoundingClientRect();
            const containerRect = boardContainer.getBoundingClientRect();

            actionMenu.style.left = (cellRect.left - containerRect.left + cellRect.width / 2 - 80) + 'px';
            actionMenu.style.top = (cellRect.top - containerRect.top - 50) + 'px';

            boardContainer.appendChild(actionMenu);
        }

        // é€²å…¥ç§»å‹•æ¨¡å¼
        function enterMoveMode() {
            if (actionMenu) {
                actionMenu.remove();
                actionMenu = null;
            }

            actionMode = 'move';

            // æ¸…é™¤ä¹‹å‰çš„é«˜äº®ï¼ˆä¸é‡æ–°æ¸²æŸ“æ•´å€‹æ£‹ç›¤ï¼‰
            document.querySelectorAll('.move-highlight, .attack-target, .splash-target, .selected').forEach(el => {
                el.classList.remove('move-highlight', 'attack-target', 'splash-target', 'selected');
            });

            const { x, y } = selectedPos;
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (cell) cell.classList.add('selected');

            // è¨ˆç®—èŠ±è²»1APå¯é”çš„æ ¼å­
            const currentAP = gameState.current_turn === 'red' ? gameState.red_ap : gameState.blue_ap;
            const apMove = UNIT_STATS[selectedUnit.type].ap_move;

            if (currentAP < apMove) {
                addLog('APä¸è¶³ï¼Œç„¡æ³•ç§»å‹•');
                cancelAction();
                return;
            }

            let highlightCount = 0;

            // 1. é«˜äº®ç›¸é„°8æ ¼ï¼ˆåŸºæœ¬ç§»å‹•ï¼‰
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < 13 && ny >= 0 && ny < 15) {
                        const targetUnit = gameState.board[`${nx}_${ny}`];
                        // ç©ºæ ¼å¯ç§»å‹•ï¼ˆ1APï¼‰ï¼Œå‹æ–¹å¯äº¤æ›ï¼ˆéœ€2APä½†å…ˆé¡¯ç¤ºï¼‰
                        if (!targetUnit || (targetUnit.team === selectedUnit.team && targetUnit.type !== 'obstacle')) {
                            const targetCell = document.querySelector(`.cell[data-x="${nx}"][data-y="${ny}"]`);
                            if (targetCell) {
                                targetCell.classList.add('move-highlight');
                                highlightCount++;
                            }
                        }
                    }
                }
            }

            // 2. é«˜äº®è·³èºç§»å‹•ï¼ˆè·³èºè·é›¢ 2-3 æ ¼ï¼Œä¸­é–“éœ€è¦ 1-3 å€‹å‹æ–¹å–®ä½ï¼‰
            const jumpDirections = [
                { dx: 0, dy: 1, name: 'ä¸‹' },
                { dx: 0, dy: -1, name: 'ä¸Š' },
                { dx: 1, dy: 0, name: 'å³' },
                { dx: -1, dy: 0, name: 'å·¦' }
            ];

            for (let dir of jumpDirections) {
                // æª¢æŸ¥è·é›¢ 2 å’Œ 3 çš„è·³èº
                for (let jumpDist = 2; jumpDist <= 3; jumpDist++) {
                    const targetX = x + dir.dx * jumpDist;
                    const targetY = y + dir.dy * jumpDist;

                    // é‚Šç•Œæª¢æŸ¥
                    if (targetX < 0 || targetX >= 13 || targetY < 0 || targetY >= 15) continue;

                    // ç›®æ¨™å¿…é ˆç‚ºç©º
                    const targetUnit = gameState.board[`${targetX}_${targetY}`];
                    if (targetUnit) continue;

                    // ä½¿ç”¨ gameEngine.canJump æª¢æŸ¥æ˜¯å¦å¯ä»¥è·³èº
                    const result = gameEngine.canJump(selectedUnit, x, y, targetX, targetY);
                    if (result.can_jump) {
                        const targetCell = document.querySelector(`.cell[data-x="${targetX}"][data-y="${targetY}"]`);
                        if (targetCell && !targetCell.classList.contains('move-highlight')) {
                            targetCell.classList.add('move-highlight');
                            highlightCount++;
                        }
                    }
                }
            }

            addLog('ç§»å‹•æ¨¡å¼ï¼šé»æ“Šç¶ è‰²æ ¼å­ç§»å‹•ï¼ˆå«è·³èºï¼‰');
        }

        // é€²å…¥æ”»æ“Šæ¨¡å¼
        function enterAttackMode() {
            if (actionMenu) {
                actionMenu.remove();
                actionMenu = null;
            }

            actionMode = 'attack';

            // æ¸…é™¤ä¹‹å‰çš„é«˜äº®ï¼ˆä¸é‡æ–°æ¸²æŸ“æ•´å€‹æ£‹ç›¤ï¼‰
            document.querySelectorAll('.move-highlight, .attack-target, .splash-target, .selected').forEach(el => {
                el.classList.remove('move-highlight', 'attack-target', 'splash-target', 'selected');
            });

            const { x, y } = selectedPos;
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (cell) cell.classList.add('selected');

            // æ›´æ–°æ£‹ç›¤rect
            const board = document.getElementById('gameBoard');
            boardRect = board.getBoundingClientRect();

            // æ·»åŠ é¼ æ¨™ç§»å‹•ç›£è½
            mouseMoveHandler = (e) => handleMouseMoveInAttackMode(e);
            document.addEventListener('mousemove', mouseMoveHandler);

            addLog('æ”»æ“Šæ¨¡å¼ï¼šç§»å‹•é¼ æ¨™ç„æº–ç›®æ¨™');
        }

        // è™•ç†æ”»æ“Šæ¨¡å¼ä¸‹çš„é¼ æ¨™ç§»å‹•
        function handleMouseMoveInAttackMode(e) {
            if (actionMode !== 'attack' || !selectedPos) return;

            // æ¯æ¬¡éƒ½é‡æ–°ç²å–boardRectï¼Œä»¥è™•ç†æ»¾å‹•
            const board = document.getElementById('gameBoard');
            boardRect = board.getBoundingClientRect();

            const { x, y } = selectedPos;
            const range = UNIT_STATS[selectedUnit.type].rng;

            // æª¢æ¸¬é¼ æ¨™ä¸‹çš„ç›®æ¨™æ ¼å­
            const cells = document.elementsFromPoint(e.clientX, e.clientY);
            const targetCell = cells.find(el => el.classList.contains('cell'));

            // æ¸…é™¤ä¹‹å‰çš„ç›®æ¨™é«˜äº®
            document.querySelectorAll('.attack-target, .splash-target').forEach(el => {
                el.classList.remove('attack-target', 'splash-target');
            });

            // é«˜äº®é‚è¼¯
            if (targetCell) {
                const tx = parseInt(targetCell.dataset.x);
                const ty = parseInt(targetCell.dataset.y);
                const dist = Math.max(Math.abs(tx - x), Math.abs(ty - y));
                const targetUnit = gameState.board[`${tx}_${ty}`];

                // å¦‚æœæ˜¯å°„ç¨‹å…§çš„æ•µæ–¹å–®ä½ï¼Œé«˜äº®
                if (targetUnit && targetUnit.team !== selectedUnit.team &&
                    targetUnit.type !== 'obstacle' && dist <= range && dist > 0) {
                    targetCell.classList.add('attack-target'); // ä¸»è¦ç›®æ¨™

                    // æ¿ºå°„å‚·å®³æª¢æŸ¥ (Mage æˆ– Can)
                    if (selectedUnit.type === 'mage' || selectedUnit.type === 'can') {
                        // 3x3 æ¿ºå°„
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                const sx = tx + dx;
                                const sy = ty + dy;
                                if (sx >= 0 && sx < 13 && sy >= 0 && sy < 15) {
                                    const splashCell = document.querySelector(`.cell[data-x="${sx}"][data-y="${sy}"]`);
                                    if (splashCell && (dx !== 0 || dy !== 0)) {
                                        splashCell.classList.add('splash-target');
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // ç¹ªè£½å‹•æ…‹æ”»æ“Šç·š (è·Ÿéš¨é¼ æ¨™)
            if (targetCell && targetCell.classList.contains('attack-target')) {
                // å¦‚æœç„æº–äº†æœ‰æ•ˆç›®æ¨™ï¼Œå¼·åˆ¶é–å®šåˆ°ç›®æ¨™ä¸­å¿ƒï¼Œç¢ºä¿ç¶ ç·šèˆ‡æ”»æ“Šè»Œè·¡ä¸€è‡´
                const rect = targetCell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                drawDynamicAttackLine(centerX, centerY);
            } else {
                // å¦å‰‡è·Ÿéš¨é¼ æ¨™
                drawDynamicAttackLine(e.clientX, e.clientY);
            }
        }

        // ç¹ªè£½å‹•æ…‹æ”»æ“Šç¯„åœç·š
        function drawDynamicAttackLine(mouseX, mouseY) {
            const svg = document.getElementById('attackRangeOverlay');
            if (!selectedPos) {
                svg.innerHTML = '';
                return;
            }

            const { x, y } = selectedPos;
            const range = UNIT_STATS[selectedUnit.type].rng;

            // ç²å–å®¹å™¨å’Œæ£‹ç›¤è³‡è¨Š
            const container = document.querySelector('.board-container');
            const containerRect = container.getBoundingClientRect();

            // ç²å–èµ·é»æ ¼å­ï¼ˆé¸ä¸­å–®ä½ï¼‰
            const selectedCell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (!selectedCell) return;
            const startRect = selectedCell.getBoundingClientRect();

            // è¨ˆç®—èµ·é»ä¸­å¿ƒï¼ˆç›¸å°æ–¼å®¹å™¨ï¼‰
            const startX = startRect.left - containerRect.left + startRect.width / 2;
            const startY = startRect.top - containerRect.top + startRect.height / 2;

            // è¨ˆç®—é¼ æ¨™ä½ç½®ï¼ˆç›¸å°æ–¼å®¹å™¨ï¼‰
            let endX = mouseX - containerRect.left;
            let endY = mouseY - containerRect.top;

            // è¨ˆç®—ç›¸å°æ–¼èµ·é»çš„å‘é‡
            let dx = endX - startX;
            let dy = endY - startY;

            // è¨ˆç®—æ ¼å­å¤§å° (è¿‘ä¼¼å€¼)
            const cellWidth = startRect.width;
            const cellHeight = startRect.height; // Should be same as width

            // å°‡åƒç´ è·é›¢è½‰æ›ç‚º"é‚è¼¯è·é›¢" (Chebyshev)
            // é€™è£¡æˆ‘å€‘ç”¨ç°¡å–®çš„æ¯”ä¾‹æ”¾å¤§ï¼šå¦‚æœæ»‘é¼ è¶…éäº† (range * cellWidth) çš„æ–¹å½¢é‚Šç•Œï¼Œå°±æˆªæ–·
            // è€ƒæ…®åˆ° Chebyshev è·é›¢æ˜¯æ–¹å½¢æ“´æ•£ï¼Œæˆ‘å€‘åˆ†åˆ¥é™åˆ¶ X å’Œ Y è»¸

            // å…è¨±ç¨å¾®è¶…å‡ºæ ¼å­ä¸­å¿ƒåˆ°é‚Šç·£çš„è·é›¢ï¼Œæ‰€ä»¥ç”¨ range + 0.5 (è¦†è“‹æ•´å€‹ç›®æ¨™æ ¼)
            // æˆ–è€…åš´æ ¼ä¸€é»ï¼Œåªå…è¨±é€£ç·šåˆ° range åŠå¾‘çš„é‚Šç·£
            const maxDistPixels = (range * cellWidth) + (cellWidth * 0.5); // è®“ç·šé ­èƒ½ç¢°åˆ°æœ€é æ ¼å­çš„ä¸­å¿ƒç”šè‡³é‚Šç·£

            // è¨ˆç®—ç›®å‰çš„ Chebyshev åƒç´ è·é›¢
            // æˆ‘å€‘å¸Œæœ›é™åˆ¶åœ¨ä»¥ start ç‚ºä¸­å¿ƒçš„æ–¹å½¢å€åŸŸå…§
            // æ–¹å½¢é‚Šé•·åŠå¾‘ = range * cellWidth (å¤§ç´„)

            // æ›´åŠ ç²¾ç¢ºçš„ç®—æ³•ï¼š
            // å¦‚æœæˆ‘å€‘æŠŠ dx, dy æ­£è¦åŒ–åˆ° "æ ¼å­å–®ä½"
            const gridDx = dx / cellWidth;
            const gridDy = dy / cellHeight;

            // Chebyshev magnitude
            const magnitude = Math.max(Math.abs(gridDx), Math.abs(gridDy));

            if (magnitude > range) {
                // éœ€è¦ç¸®çŸ­
                const scale = range / magnitude;
                dx *= scale;
                dy *= scale;
                endX = startX + dx;
                endY = startY + dy;
            }

            // ç¹ªè£½SVGç·š
            svg.innerHTML = `<line class="attack-range-line" x1="${startX}" y1="${startY}" x2="${endX}" y2="${endY}" />`;
        }

        // å–æ¶ˆæ“ä½œ
        function cancelAction() {
            actionMode = null;

            if (actionMenu) {
                actionMenu.remove();
                actionMenu = null;
            }

            if (mouseMoveHandler) {
                document.removeEventListener('mousemove', mouseMoveHandler);
                mouseMoveHandler = null;
            }

            const svg = document.getElementById('attackRangeOverlay');
            if (svg) svg.innerHTML = '';

            selectedUnit = null;
            selectedPos = null;
            renderBoard();
        }

        // åŸ·è¡Œç§»å‹•
        async function performMove(tx, ty) {
            const { x, y } = selectedPos;
            const targetUnit = gameState.board[`${tx}_${ty}`];

            let moveType = 'move';
            if (targetUnit && targetUnit.team === selectedUnit.team) {
                moveType = 'swap';
            } else if (Math.abs(tx - x) > 1 || Math.abs(ty - y) > 1) {
                moveType = 'jump';
            }

            const result = gameEngine.executeMove(selectedUnit.id, tx, ty, moveType);

            if (result.success) {
                gameState = gameEngine.state;
                addLog(`${selectedUnit.team === 'red' ? 'ç´…æ–¹' : 'è—æ–¹'} ${UNIT_NAMES[selectedUnit.type]} ${result.message} åˆ° (${tx},${ty}) [æ¶ˆè€— ${result.ap_used} AP]`);
                cancelAction();
                updateUI();

                // æª¢æŸ¥æ˜¯å¦éœ€è¦è‡ªå‹•æ›å›åˆ
                if (result.auto_turn_end) {
                    setTimeout(() => {
                        endTurn(true); // å‚³å…¥ true è¡¨ç¤ºè‡ªå‹•æ›å›åˆ
                    }, 500);
                }
            } else {
                alert(result.error);
                cancelAction();
            }
        }

        // åŸ·è¡Œæ”»æ“Š
        async function performAttack(tx, ty) {
            // 1. å…ˆåŸ·è¡Œé‚è¼¯æª¢æŸ¥ (æª¢æŸ¥AP, å†·å», å°„ç¨‹ç­‰)
            // å…ˆå‚™ä»½ç‹€æ…‹ï¼Œé›–ç„¶executeAttackæœƒç›´æ¥ä¿®æ”¹stateï¼Œä½†æˆ‘å€‘é‚„æ²’renderBoardï¼Œæ‰€ä»¥ç•«é¢ä¸Šé‚„æ˜¯èˆŠçš„
            const result = gameEngine.executeAttack(selectedUnit.id, tx, ty);

            if (!result.success) {
                alert(result.error);
                cancelAction();
                return;
            }

            // 2. é‚è¼¯æª¢æŸ¥é€šéï¼Œæ’­æ”¾æ”»æ“Šå‹•ç•«çš„ç›®æ¨™æ‡‰è©²æ˜¯å¯¦éš›å‘½ä¸­é»ï¼ˆå¯èƒ½è¢«é˜»æ“‹ï¼‰
            let actualTx = tx;
            let actualTy = ty;

            // ä½¿ç”¨å¾Œç«¯è¿”å›çš„å¯¦éš›å‘½ä¸­åº§æ¨™ï¼ˆå„ªå…ˆï¼‰
            if (result.final_x !== undefined && result.final_y !== undefined) {
                actualTx = result.final_x;
                actualTy = result.final_y;
            }
            // å‚™ç”¨ï¼šå¾äº‹ä»¶ä¸­å°‹æ‰¾ä¸»è¦å‚·å®³äº‹ä»¶
            else if (result.events && result.events.length > 0) {
                // é€šå¸¸ç¬¬ä¸€å€‹å‚·å®³äº‹ä»¶å°±æ˜¯ä¸»è¦ç›®æ¨™ï¼ˆå› ç‚ºæ¿ºå°„æ˜¯åœ¨ä¹‹å¾Œpushçš„ï¼‰
                // æˆ–è€…æ˜¯è¢«é˜»æ“‹çš„ç›®æ¨™
                const mainHit = result.events[0];
                if (mainHit && mainHit.type === 'damage') {
                    actualTx = mainHit.x;
                    actualTy = mainHit.y;
                }
            }

            // æ³¨æ„ï¼šæ­¤æ™‚ gameState å·²ç¶“è¢«æ›´æ–°äº† (HPå·²æ‰£é™¤)ï¼Œä½† DOM (renderBoard) é‚„æ²’æ›´æ–°
            // é€™æ­£æ˜¯æˆ‘å€‘æƒ³è¦çš„ï¼šåœ¨èˆŠç•«é¢ä¸Šæ’­æ”¾å‹•ç•« -> å‹•ç•«çµæŸ -> updateUI (é¡¯ç¤ºæ–°HP/æ­»äº¡)
            await animateAttack(selectedUnit, actualTx, actualTy);
            // é€™è£¡å‚³å…¥ actualTx, actualTy çµ¦ triggerHitEffect (åœ¨ animateAttack å…§éƒ¨èª¿ç”¨)
            // ç¢ºä¿çˆ†ç‚¸ç™¼ç”Ÿåœ¨æ­£ç¢ºä½ç½®

            gameState = gameEngine.state;

            // è™•ç†æˆ°é¬¥äº‹ä»¶
            result.events.forEach(event => {
                if (event && event.type === 'damage') {
                    const targetUnit = event.unit_id;
                    const protectedTag = event.protected ? ' [å°‡è»ä¿è­·]' : '';
                    const msg = `${selectedUnit.team === 'red' ? 'ç´…æ–¹' : 'è—æ–¹'} ${UNIT_NAMES[selectedUnit.type]} æ”»æ“Š (${event.x},${event.y}) é€ æˆ ${event.damage} é»å‚·å®³${protectedTag}`;
                    addLog(msg, event.died ? 'death' : 'damage');

                    if (event.died) {
                        addLog(`å–®ä½é™£äº¡ï¼`, 'death');
                    }
                }
            });

            addLog(`æ¶ˆè€— ${result.ap_used} AP`);

            cancelAction();
            updateUI();
            renderBoard(); // ç¢ºä¿è¡€é‡æ›´æ–°

            if (gameState.game_over) {
                showVictory();
            } else if (result.auto_turn_end) {
                // è‡ªå‹•æ›å›åˆ
                setTimeout(() => {
                    endTurn(true); // å‚³å…¥ true è¡¨ç¤ºè‡ªå‹•æ›å›åˆ
                }, 500);
            }
        }

        // è™•ç†æ”»æ“Šå‹•ç•«
        function animateAttack(attacker, tx, ty) {
            return new Promise(resolve => {
                const { x: sx, y: sy } = gameEngine.findUnitPosition(attacker.id) ? { x: gameEngine.findUnitPosition(attacker.id)[0], y: gameEngine.findUnitPosition(attacker.id)[1] } : selectedPos;

                // ç²å–èµ·é»å’Œçµ‚é»çš„è¢å¹•åº§æ¨™
                const startCell = document.querySelector(`.cell[data-x="${sx}"][data-y="${sy}"]`);
                const targetCell = document.querySelector(`.cell[data-x="${tx}"][data-y="${ty}"]`);

                if (!startCell || !targetCell) {
                    resolve();
                    return;
                }

                const sRect = startCell.getBoundingClientRect();
                const tRect = targetCell.getBoundingClientRect();
                const container = document.querySelector('.board-container');
                const cRect = container.getBoundingClientRect();

                // è¨ˆç®—ç›¸å°åº§æ¨™
                const startX = sRect.left - cRect.left + sRect.width / 2;
                const startY = sRect.top - cRect.top + sRect.height / 2;
                const endX = tRect.left - cRect.left + tRect.width / 2;
                const endY = tRect.top - cRect.top + tRect.height / 2;

                // æ ¹æ“šå…µç¨®æ±ºå®šç‰¹æ•ˆ
                const type = attacker.type;

                // æ‰€æœ‰æ”»æ“Šéƒ½ä½¿ç”¨æŠ•å°„ç‰©å‹•ç•«ï¼ˆåŒ…æ‹¬è¿‘æˆ°åŠæ°£ï¼‰
                const projectile = document.createElement('div');
                projectile.className = 'projectile';
                const img = document.createElement('img');

                if (type === 'arc') {
                    projectile.classList.add('arrow');
                    img.src = 'assets/projectile_arrow.svg';
                } else if (type === 'mage') {
                    projectile.classList.add('fireball');
                    img.src = 'assets/projectile_fireball.svg';
                } else if (type === 'can') {
                    projectile.classList.add('cannonball');
                    img.src = 'assets/projectile_cannonball.svg';
                } else {
                    // è¿‘æˆ° (Soldier, General, King) - åŠæ°£é£›å‡º
                    projectile.classList.add('slash');
                    img.src = 'assets/projectile_slash.svg';
                }

                projectile.appendChild(img);
                container.appendChild(projectile);

                // è¨­ç½®åˆå§‹ä½ç½®
                // ç®­çŸ¢å°ºå¯¸ç‚º 60x20ï¼Œä¸­å¿ƒé»åœ¨ 30,10
                // ä½†æ˜¯ CSS ä¸­ .projectile.arrow å…¶å¯¦è¢«è¨­å®šç‚º width: 30px (è¢«æ¨£å¼è¦†è“‹)
                // ç‚ºäº†è®“ç®­çŸ¢çœ‹èµ·ä¾†ä¸åƒè¢«å£“ç¸®ï¼Œæˆ‘å€‘æ‡‰è©²è®“å®¹å™¨å¤§å°ç¬¦åˆ SVG
                if (type === 'arc') {
                    projectile.style.width = '60px'; // ä½¿ç”¨çœŸå¯¦å¯¬åº¦
                    projectile.style.height = '20px';
                    // ä¿®æ­£åç§»é‡ï¼Œè®“ä¸­å¿ƒå°é½Š startX, startY
                    projectile.style.left = (startX - 30) + 'px'; // 30 is half of 60
                    projectile.style.top = (startY - 10) + 'px'; // 10 is half of 20
                    projectile.style.transformOrigin = '30px 10px'; // å¼·åˆ¶æŒ‡å®šæ—‹è½‰ä¸­å¿ƒ
                    projectile.style.zIndex = '1000'; // ç¢ºä¿åœ¨æœ€ä¸Šå±¤
                } else {
                    // å…¶ä»–æ­£æ–¹å½¢æŠ•å°„ç‰© (40x40 æˆ–é¡ä¼¼)
                    // .projectile é è¨­ 40x40 -> offset 20
                    // .fireball, .slash ç­‰æœ‰å„è‡ªçš„å¤§å°ï¼Œé€™è£¡ç°¡åŒ–è™•ç†ï¼Œå‡è¨­å¤§ç´„å±…ä¸­
                    let size = 40;
                    if (type === 'mage') size = 50; // .fireball
                    if (type === 'can') size = 20; // .cannonball
                    if (type === 'melee' || type === 'king' || type === 'gen' || type === 'sol') size = 60; // .slash

                    const offset = size / 2;
                    // éœ€è¦åŒæ™‚èª¿æ•´ element size (å› ç‚º CSS class å¯èƒ½ä¸å¤ ç²¾ç¢º)
                    projectile.style.width = size + 'px';
                    projectile.style.height = size + 'px';
                    projectile.style.left = (startX - offset) + 'px';
                    projectile.style.top = (startY - offset) + 'px';
                }

                // è¨ˆç®—è§’åº¦
                const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
                projectile.style.transform = `rotate(${angle}deg)`;

                // å¼·åˆ¶é‡ç¹ª
                projectile.offsetHeight;

                // è¨­ç½®éæ¸¡å’Œçµ‚é»
                const distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                // è¿‘æˆ°åŠæ°£é€Ÿåº¦ç¨å¾®å¿«ä¸€é»? æˆ–è€…çµ±ä¾
                const duration = Math.min(0.5, distance / 500); // æ ¹æ“šè·é›¢èª¿æ•´é€Ÿåº¦

                projectile.style.transition = `left ${duration}s linear, top ${duration}s linear`;

                if (type === 'arc') {
                    projectile.style.left = (endX - 30) + 'px';
                    projectile.style.top = (endY - 10) + 'px';
                } else {
                    let size = 40;
                    if (type === 'mage') size = 50;
                    if (type === 'can') size = 20;
                    if (type === 'melee' || type === 'king' || type === 'gen' || type === 'sol') size = 60;
                    const offset = size / 2;
                    projectile.style.left = (endX - offset) + 'px';
                    projectile.style.top = (endY - offset) + 'px';
                }

                // å‹•ç•«çµæŸå¾Œ
                setTimeout(() => {
                    projectile.remove();
                    // è§¸ç™¼çˆ†ç‚¸/å‘½ä¸­ç‰¹æ•ˆ
                    triggerHitEffect(type, tx, ty);
                    resolve();
                }, duration * 1000);
            });
        }

        // è§¸ç™¼å‘½ä¸­/çˆ†ç‚¸ç‰¹æ•ˆ
        function triggerHitEffect(type, tx, ty) {
            const container = document.querySelector('.board-container');
            const targetCells = [];

            // ç¢ºå®šå—å½±éŸ¿çš„æ ¼å­
            if (type === 'mage' || type === 'can') {
                // 3x3 ç¯„åœ
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const nx = tx + dx;
                        const ny = ty + dy;
                        if (nx >= 0 && nx < 13 && ny >= 0 && ny < 15) {
                            // åˆ¤æ–·æ˜¯å¦æœ‰å–®ä½æˆ–åªæ˜¯é¡¯ç¤ºç‰¹æ•ˆ?
                            // åªè¦åœ¨ç¯„åœå…§éƒ½é¡¯ç¤ºçˆ†ç‚¸
                            targetCells.push({ x: nx, y: ny });
                        }
                    }
                }
            } else {
                // å–®é«”
                targetCells.push({ x: tx, y: ty });
            }

            targetCells.forEach(pos => {
                const cell = document.querySelector(`.cell[data-x="${pos.x}"][data-y="${pos.y}"]`);
                if (!cell) return;

                const rect = cell.getBoundingClientRect();
                const cRect = container.getBoundingClientRect();

                const effect = document.createElement('div');

                if (type === 'melee' || type === 'king' || type === 'gen' || type === 'sol' || type === 'arc') {
                    // åŠæ°£å’Œç®­çŸ¢(arc)å·²ä½œç‚ºæŠ•å°„ç‰©é£›å‡ºï¼Œæ­¤è™•ä¸å†é¡¯ç¤ºé¡å¤–çš„éœæ…‹ç‰¹æ•ˆ
                    // ç§»é™¤é‡è¤‡çš„ effect-slash
                    return;
                } else {
                    effect.className = 'effect-explosion';
                }

                effect.style.left = (rect.left - cRect.left) + 'px';
                effect.style.top = (rect.top - cRect.top) + 'px';
                effect.style.width = rect.width + 'px';
                effect.style.height = rect.height + 'px';

                container.appendChild(effect);

                // å‹•ç•«çµæŸå¾Œç§»é™¤
                setTimeout(() => {
                    effect.remove();
                }, 500);
            });
        }

        // çµæŸå›åˆ
        async function endTurn(isAuto = false) {
            cancelAction(); // æ¸…é™¤ä»»ä½•é€²è¡Œä¸­çš„æ“ä½œ

            const result = gameEngine.endTurn();

            if (result.success) {
                gameState = gameEngine.state;
                renderBoard();
                updateUI();

                // é¡¯ç¤ºéæœŸæ•ˆæœæ—¥èªŒ
                if (result.expired_effects) {
                    result.expired_effects.forEach(effect => {
                        const teamName = effect.team === 'red' ? 'ç´…æ–¹' : 'è—æ–¹';
                        addLog(`${teamName}å°‡è»çš„${effect.message}`);
                    });
                }

                addLog(`===== å›åˆ ${gameState.turn_count} é–‹å§‹ =====`);
                addLog(`${gameState.current_turn === 'red' ? 'ç´…æ–¹' : 'è—æ–¹'} å›åˆé–‹å§‹`);

                // é¡¯ç¤ºä¸­å¤®æç¤ºè¨Šæ¯
                const turnText = gameState.current_turn === 'red' ? 'ç´…æ–¹å›åˆ' : 'è—æ–¹å›åˆ';
                showCentralMessage(turnText, 'turn');

                // Trigger AI if PVE and now Red turn
                if (isPVE && gameState.current_turn === 'red') {
                    // Slight delay for UX
                    setTimeout(() => processAITurn(), 500);
                }
            }
        }

        // é‡æ–°é–‹å§‹ - Function definition moved to global scope
        /* 
        function resetGame() {
            if (confirm('ç¢ºå®šè¦é‡æ–°é–‹å§‹éŠæˆ²å—ï¼Ÿ')) {
                cancelAction(); 
                initGame();
                document.getElementById('logContent').innerHTML = '';
            }
        }
        */

        // æ›´æ–°UI
        function updateUI() {
            const turnIndicator = document.getElementById('turnIndicator');
            const apCounter = document.getElementById('apCounter');

            if (gameState.current_turn === 'red') {
                turnIndicator.textContent = 'ç´…æ–¹å›åˆ';
                turnIndicator.className = 'turn-indicator turn-red';
                apCounter.textContent = `AP: ${gameState.red_ap}`;
            } else {
                turnIndicator.textContent = 'è—æ–¹å›åˆ';
                turnIndicator.className = 'turn-indicator turn-blue';
                apCounter.textContent = `AP: ${gameState.blue_ap}`;
            }

            // End Turn Button Visibility in PVE
            const endTurnBtn = document.querySelector('.btn-end-turn');
            if (endTurnBtn) {
                if (isPVE && gameState.current_turn === 'red') {
                    endTurnBtn.style.display = 'none';
                } else {
                    endTurnBtn.style.display = 'inline-block';
                }
            }
        }

        // é¡¯ç¤ºå‹åˆ©è¨Šæ¯
        function showVictory() {
            const victoryMessage = document.getElementById('victoryMessage');
            const winner = gameState.winner === 'red' ? 'ç´…æ–¹' : 'è—æ–¹';
            victoryMessage.textContent = `ğŸ‰ ${winner} ç²å‹ï¼ğŸ‰`;
            victoryMessage.style.display = 'block';
            addLog(`========== ${winner} ç²å‹ï¼ ==========`, 'death');

            // é¡¯ç¤ºä¸­å¤®æç¤ºè¨Šæ¯
            showCentralMessage(`${winner} å‹åˆ©ï¼`, 'victory');
        }

        // é¡¯ç¤ºä¸­å¤®æç¤ºè¨Šæ¯
        function showCentralMessage(text, type) {
            const messageDiv = document.getElementById('centralMessage');
            messageDiv.textContent = text;
            messageDiv.className = `central-message ${type}`;
            messageDiv.style.display = 'flex';

            // 2ç§’å¾Œè‡ªå‹•éš±è—ï¼ˆå‹åˆ©è¨Šæ¯é™¤å¤–ï¼‰
            if (type !== 'victory') {
                setTimeout(() => {
                    messageDiv.style.display = 'none';
                }, 2000);
            }
        }

        // æ·»åŠ æ—¥èªŒ
        function addLog(message, type = 'info') {
            const logContent = document.getElementById('logContent');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;

            // å¦‚æœå½ˆå‡ºè¦–çª—æ˜¯æ‰“é–‹çš„ï¼Œä¹ŸåŒæ­¥æ›´æ–°
            const modal = document.getElementById('logModal');
            if (modal && modal.classList.contains('active')) {
                const modalContent = document.getElementById('logModalContent');
                modalContent.innerHTML = logContent.innerHTML;
                modalContent.scrollTop = modalContent.scrollHeight;
            }
        }

        // åˆ‡æ›æˆ°é¬¥è¨˜éŒ„é¡¯ç¤º
        function toggleLog() {
            const modal = document.getElementById('logModal');
            const logContent = document.getElementById('logContent');
            const modalContent = document.getElementById('logModalContent');

            if (modal.classList.contains('active')) {
                // é—œé–‰
                modal.classList.remove('active');
            } else {
                // æ‰“é–‹ä¸¦åŒæ­¥å…§å®¹
                modalContent.innerHTML = logContent.innerHTML;
                modal.classList.add('active');
                modalContent.scrollTop = modalContent.scrollHeight;
            }
        }

        // é é¢è¼‰å…¥æ™‚åˆå§‹åŒ– - å·²åœ¨é ‚éƒ¨ gameEngine åˆå§‹åŒ–å¾Œè™•ç†
        // window.onload = initGame; // ç§»é™¤æ­¤è¡Œï¼Œé¿å…è¦†è“‹é ‚éƒ¨çš„åˆå§‹åŒ–é‚è¼¯
    </script>
</body>

</html>